# [BaaaaaaaarkingDog](https://blog.encrypted.gg/)의 실전 알고리즘 0x01강 ~ 0x02강 - 기초 코드 작성 요령



## STL과 함수 인자

함수 인자로 원시 타입을 사용하면 Call by value 방식으로 복사되어 전달된다는 것은 상식이다.

* 구조체를 사용해도 마찬가지로 Call by value 방식이다.

포인터, 또는 배열을 사용하면 ~~실제로는 Call by value이지만,~~포인터의 특성으로 인해 Call by reference 처럼 작동한다. (= Call by Pointer)

C++에서는 포인터 대신 레퍼런스 자료형을 사용하여 Call by reference 방식을 구현한다.



STL에서 제공하는 자료형들은 함수의 인자로 사용되었을 때 기본적으로 Call by value 방식으로 작동한다.

* 따라서, 함수에 인자로 넘겨졌을 때, 컨테이너 내부의 데이터를 모두 복사하는 과정이 발생하게 된다.

* ```c++
  bool cmp1(vector<int> v1, vector<int> v2) {
      return v1[0] > v2[0];
  }
  ```

* 위 함수는 두 `vector<int>`의 첫 원소를 비교하기 때문에 `O(1)`의 시간복잡도를 가질 것 같지만, `vector<int>`의 복사 과정으로 인해 실제로는 `O(n)`의 시간복잡도를 가지게 된다.



## 표준 입출력

C++ string은 편하다. `char*`를 쓸 일이 있다면 형 변환해서 C++ string으로 작업하고 마지막에 `c_str()`로 `char*`형으로 되돌리는 것을 권장.



### 공백을 포함한 문자열

3가지 방법이 있다.

* `scanf("%[^\n]", char_array);`
* `gets(char_array)` : 보안상의 이유로 C++14 이상에서는 지원 안함
* `getline(cin, str)` : 권장하는 방법
  * C++ string만 지원함.



### 시간 초과 방지

```c++
ios::sync_with_stdio(false); // false 대신 0써도 됨.
```

scanf/printf 에서 사용하는 표준 입출력 스트림 C stream과 cin/cout에서 사용하는 C++ stream은 분리가 되어있다. 그런데 scanf/printf와 cin/cout을 혼용하면 프로그래머의 의도대로 되지 않을 수 있음.

```c++
int main() {
	ios::sync_with_stdio(0);
    cout << "1\n";
    printf << "2\n";
    cout << "3\n";
    return 0;
}
/* 결과
2
1
3
*/
```

그래서 둘을 동기화해주는데, 이것이 sync_with_stdio임. 이를 끊어서 프로그램 수행 시간의 이득을 볼 수 있음. 단, `sync_with_stdio(false)`를 사용한 후에는 printf/scanf를 사용하면 입출력 순서가 꼬일 수 있으므로 사용하면 안됨!

* 참고 : VS 2017/2019에서는 sync_with_stdio를 무시하고 무조건 동기화를 유지해서 위 코드의 결과가 1,2,3으로 나올 수 있음. 그러나 gcc에서는 차이가 분명히 있다. (채점 서버도 gcc 사용함)



```c++
cin.tie(nullptr);	// null은 0으로 바꿔써도 됨
```

입출력이 번갈아가며 반복되는 상황에서는 입력에 대한 출력이 다음 입력 전에 반드시 출력되기를 기대하는 것이 보통이다.

```c++
for(int i=0; i<n; i++){
    int a, b;
    cin >> a >> b;
    cout << a+b << "\n";
}
/* 기대하는 결과
입력 : 14 104
출력 : 118
입력 : 2 5
출력 : 7
*/
```

따라서, cin과 cout은 기본적으로 입력/출력하기 전에 출력/입력 버퍼를 비워버린다.

* cin은 입력을 받기 전에 cout버퍼를 비워서 콘솔에 출력값을 출력한다.
  * cin 이전 행에 `std::cout << std::flush`가 삽입된 것과 같은 효과

그런데, 알고리즘 채점 서버는 사람과 달리 입출력의 순서가 딱히 상관 없다. 출력값이 맞기만 하면 정답으로 쳐준다. 따라서, 입출력에 걸리는 시간을 줄이고자 `cin.tie(null)`을 사용함.



`cin.tie(null)`과 유사하게, `endl`은 강제로 버퍼를 비우는 효과가 있으므로 프로그램 시간에 악영향을 끼치니 `'\n'`으로 대체하고 사용하지 않는다.



## 코드 작성 팁

코딩 테스트와 실제 개발은 다르다.

코딩 테스트

* 제한된 시간 안에 정답을 받아야 한다.
* 제한 조건에만 들어간다면 사용하는 메모리나 시간은 전혀 상관없음. 

실제 개발

* 깔끔한 코드
* 필요한 만큼만 메모리 사용



출력 맨 마지막에 공백/개행문자가 들어있어도 상관없음.



바킹독의 개인적인 의견이지만, 코딩 테스트의 100줄 이하의 코드에서는 디버거보단 직접 출력해보는 게 낫다는 의견