# 리스트, 스택, 큐



성능과 안정성을 확보하기 위해서는 적절한 자료구조 선택이 매우 중요하다. 우선 선형(linear, 1차원)자료구조부터 알아보자.



선형적인 자료를 저장하는 방식은 크게 두가지로 구분할 수 있다.

* 연속된 자료 구조 (contiguous data structures)
  * 모든 원소를 단일 덩어리(chunk)로 묶어서 저장. (예시 : 배열)
  * 원소에 접근 시간이 O(1)
  * 실전에서는, 캐시의 지역성으로 인해, 연속된 자료 구조에서의 인접한 원소를 가지고 올 때 속도면에서 이점이 있음
    * 단, 이것이 점근적 시간 복잡도 (Big-O 표기법)에는 반영되지는 않음.
  * 다만 삽입과 삭제가 번거로움
* 연결된 자료 구조 (linked data structures)
  * 데이터와 다음 노드를 가리키는 포인터로 구성된 노드의 집합 (예시 : 연결 리스트)
  * 원소에 접근 시간이 O(n)
  * 캐시의 지역성을 기대할 수 없음.
  * 삽입과 삭제가 용이함.
  * 각 노드에서의 next 포인터 사용을 위해 추가적인 메모리를 요구함.



배열과 연결 리스트는 매우 범용적으로 쓰이기 때문에 무결성과 효율성이 요구됨. 

그러니 굳이 새로 만들어서 쓰지 말고 무결성과 효율성이 검증된 기본제공 클래스들을 사용하도록 하자.

* std::array
* std::vector
* std::list
* 등등



### std::array

기존 C 스타일의 배열은 여러 문제점들이 있었다.

* 메모리 할당과 해제를 수동으로 해야 하기 때문에 메모리 누수의 가능성이 있음
* ```[ ]```연산자에서 적절하지 않은 인덱스를 검사하지 못하여 segmentation fault의 가능성이 있음
* 배열을 중첩해서 사용할 시, 문법이 복잡해짐
* 기본적으로 얕은 복사임. 깊은 복사는 수동으로 구현해야 함.



그래서 이러한 문제점들을 회피하기 위해 C++에서는 ```std::array```라는 클래스 템플릿을 제공함.



```cpp
std::array<T, size> arr1;
```



특징

* ```[]```연산자 뿐만 아니라 ```at(int)``` 함수를 제공함

  * ```at(int)```함수 사용하여 원소 접근 시, 약간의 성능을 희생하는 대신 index out of range를 검사할 수 있으며, exception을 통해 예외 처리를 할 수 있음.

* 값 또는 참조로 전달할 수 있고, const도 사용 가능.

  * C 스타일의 배열처럼 포인터를 사용하여 전달하지 않아도 됨.
  * 기본적으로 깊은 복사를 사용하지만, 참조 또는 const 참조를 사용하여 얕은 복사를 선택할 수 있음.

* type에 size_t가 포함되어 있음.

  * ```array<int, 5>```와 ```array<int, 10>```은 다른 타입임

  * 함수 매개변수의 타입 문제는 템플릿을 사용하여 해결

    * ```cpp
      template <size_t N>
      void print(const std::array<int, N>& arr);
      ```

* ```begin()```과 ```end()``` 제공

  * array의 size를 몰라도 처음부터 끝까지 for문을 돌릴 수 있음

    * ``` cpp
      for(auto element : arr) {...}
      // 또는
      for(auto it = arr.begin(); it != arr.end(); it++) {...}
      ```

* ```data()```함수를 사용하여 기존의 포인터를 인자로 받는 (C스타일 배열을 사용하는) 함수에 대응할 수 있음.

* 깊은 복사 뿐만 아니라 깊은 비교 또한 지원함.

  * C스타일 배열은 ```<```, ```==```등의 비교 연산자 사용 시 포인터 주소 값을 비교했지만 (얕은 비교), ```std::array```를 사용하면 배열의 내용물을 비교함. (깊은 비교)
  * 함수의 타입에 size_t가 포함되어 있기 때문에 서로 다른 크기의 배열은 서로 비교할 수 없음.





